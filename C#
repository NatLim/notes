1.List<T> collection
  ArrayList collection
  List has a unique data type while arraylist may store different types of objects.

2.Int to String
int.ToString()

3.if you want to initilize an array you need to defind the size of it, no matter one 1d or 2d, the same.

4.C# foreach syntax:
var fibNumbers = new List<int> { 0, 1, 1, 2, 3, 5, 8, 13 };
foreach (int element in fibNumbers)

5.C# stack
init:var stack = new Stack<Node>();
stack.Push --> push a new element to stack
stack.Pop() --> pops up the top element and remove it from the stack
stack.Peek() --> gives you the top element in the stack and do not remove it from the stack
stack.Count --> stack's counting number
stack.Clear() --> clean the whole stack.

6.C# string split
string s = "there is a cat";
string[] words = s.Split(' ');
        foreach (string word in words)
        {
            Console.WriteLine(word);
        }
        
output result:

there
is
a
cat

7. string property:
Property or indexer 'string.this[int]' cannot be assigned to -- it is read only
You can't assign a string's val by its index.

8. Operator	Description	Example

The Bitwise operators supported by C# are listed in the following table. Assume variable A holds 60 and variable B holds 13, then 
&	Binary AND Operator copies a bit to the result if it exists in both operands.	(A & B) = 12, which is 0000 1100
|	Binary OR Operator copies a bit if it exists in either operand.	(A | B) = 61, which is 0011 1101
^	Binary XOR Operator copies the bit if it is set in one operand but not both.	(A ^ B) = 49, which is 0011 0001
~	Binary Ones Complement Operator is unary and has the effect of 'flipping' bits.	(~A ) = 61, which is 1100 0011 in 2's complement due to a signed binary number.
<<	Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand.	A << 2 = 240, which is 1111 0000
>>	Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand.	A >> 2 = 15, which is 0000 1111

9. The HashSet<T> data structure:

HashSet<T> is more or less modeled after a mathematical set, which means that:

It may contain no duplicate values.

Its elements are in no particular order; therefore the type does not implement the IList<T> interface, but the more basic ICollection<T>. As a consequence, elements inside a hash set cannot be randomly accessed through indices; they can only be iterated over through an enumerator.

Certain set functions such as Union, Intersection, IsSubsetOf, IsSupersetOf are available. These can come in handy when working with multiple sets.


Why not List<T>?

Since a HashSet<T> is simply a collection of unique objects, you might wonder why it has to be a data structure. A normal List<T> could have the same behavior by checking if an object is found in the list before adding it.

The short answer is speed. Searching through a normal List<T> gets very slow very fast as more elements are added. A HashSet<T> requires a structure design that will allow for fast searching and insertion speeds.

10. get the sum of all elements in List<int>
double total = myList.Sum();


11. remove the last element in a list 

rows.RemoveAt(rows.Count - 1);

12.
通过上面几节中的介绍和本节中的分析，我们可以总结出DataSet对象的三大特性：
（1） 独立性。DataSet独立于各种数据源。
（2） 离线（断开）和连接。
（3） DataSet对象是一个可以用XML形式表示的数据视图，是一种数据关系视图。

在实际应用中，DataSet使用方法一般有三种：
（1） 把数据库中的数据通过DataAdapter对象填充DataSet。
（2） 通过DataAdapter对象操作DataSet实现更新数据库。
（3） 把XML数据流或文本加载到DataSet

13.
什么是三层架构
三层架构就是把整个软件系统分为三个层次

表现层（Presentation layer）
业务逻辑层（Business Logic Layer）
数据访问层（Data access layer）

表现层（Presentation layer）：表现层可以说是距离用户最近的层，主要是用于接收用户输入的数据和显示处理后用户需要的数据。一般表现为界面，用户通过界面输入查询数据和得到需要的数据。
业务逻辑层（Business Logic Layer）：业务逻辑层是处于表现层和数据访问层之间，主要是从数据库中得到数据然后对数据进行逻辑处理。
数据访问层（Data access layer）：数据访问层是直接和数据库打交道的，对数据进行“增、删、改、查”等基本的操作。
不知道大家和我有没有同样的困惑：为什么中间要有业务逻辑层？为什么数据访问层不能对数据进行逻辑处理呢?少了中间一层不是减少了代码量吗？

我后来想了很久，查了很多资料，突然有所感悟，试着用自己语言描述下其中缘由。

用户对应为：食客；（食客通过服务员点单）
表现层对应为：服务员；（服务员负责食客的点单和上菜）
业务逻辑层对应为：主厨；（主厨从服务员那获得通知，向助手要原材料，并将原材料绘制成成品交给服务员）
数据访问层对应为：助手；（助手从主厨那获得通知，提交给主厨原材料）


小结一下：表现层的代码只是起到和用户交互的一个功能，采集信息反馈结果。

：业务逻辑层是通过数据访问层拿到存在数据库里的原始数据，然后再对数据进行逻辑上的处理，比如说验证。

：数据访问层的代码都是对数据库数据的“增删改查”，是原子性的不可以再细分的

：实体层不是三层架构中的任意一层，它起到一个贯穿三层架构的作用。在上述例子中Student的对象就贯穿了业务逻辑层和数据访问层。至于为什么要用一个类来贯穿三层架构，而不是直接用变量来连接，是因为有的时候变量可能会很多，如学生在后期可能要添加了“省份”，“学校”，“年级”，“班级”等等属性，那么就会很麻烦，但是面向对象编程的话，就可以很轻松地把属性封装在一个对象里，传递参数也方便。

