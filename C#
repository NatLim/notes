1.List<T> collection
  ArrayList collection
  List has a unique data type while arraylist may store different types of objects.

2.Int to String
int.ToString()

3.if you want to initilize an array you need to defind the size of it, no matter one 1d or 2d, the same.

4.C# foreach syntax:
var fibNumbers = new List<int> { 0, 1, 1, 2, 3, 5, 8, 13 };
foreach (int element in fibNumbers)

5.C# stack
init:var stack = new Stack<Node>();
stack.Push --> push a new element to stack
stack.Pop() --> pops up the top element and remove it from the stack
stack.Peek() --> gives you the top element in the stack and do not remove it from the stack
stack.Count --> stack's counting number
stack.Clear() --> clean the whole stack.

6.C# string split
string s = "there is a cat";
string[] words = s.Split(' ');
        foreach (string word in words)
        {
            Console.WriteLine(word);
        }
        
output result:

there
is
a
cat

7. string property:
Property or indexer 'string.this[int]' cannot be assigned to -- it is read only
You can't assign a string's val by its index.

8. Operator	Description	Example

The Bitwise operators supported by C# are listed in the following table. Assume variable A holds 60 and variable B holds 13, then 
&	Binary AND Operator copies a bit to the result if it exists in both operands.	(A & B) = 12, which is 0000 1100
|	Binary OR Operator copies a bit if it exists in either operand.	(A | B) = 61, which is 0011 1101
^	Binary XOR Operator copies the bit if it is set in one operand but not both.	(A ^ B) = 49, which is 0011 0001
~	Binary Ones Complement Operator is unary and has the effect of 'flipping' bits.	(~A ) = 61, which is 1100 0011 in 2's complement due to a signed binary number.
<<	Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand.	A << 2 = 240, which is 1111 0000
>>	Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand.	A >> 2 = 15, which is 0000 1111

9. The HashSet<T> data structure:

HashSet<T> is more or less modeled after a mathematical set, which means that:

It may contain no duplicate values.

Its elements are in no particular order; therefore the type does not implement the IList<T> interface, but the more basic ICollection<T>. As a consequence, elements inside a hash set cannot be randomly accessed through indices; they can only be iterated over through an enumerator.

Certain set functions such as Union, Intersection, IsSubsetOf, IsSupersetOf are available. These can come in handy when working with multiple sets.


Why not List<T>?

Since a HashSet<T> is simply a collection of unique objects, you might wonder why it has to be a data structure. A normal List<T> could have the same behavior by checking if an object is found in the list before adding it.

The short answer is speed. Searching through a normal List<T> gets very slow very fast as more elements are added. A HashSet<T> requires a structure design that will allow for fast searching and insertion speeds.

10. get the sum of all elements in List<int>
double total = myList.Sum();


11. remove the last element in a list 

rows.RemoveAt(rows.Count - 1);





